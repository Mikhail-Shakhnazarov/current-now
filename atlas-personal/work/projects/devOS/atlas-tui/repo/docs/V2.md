# V2 sketch

V2 is the first pass where Atlas TUI becomes visibly interactive, while still deferring real provider calls and automatic execution.

The goal of v2 is to validate the most important internal invariant: user chat input plus UI state is transformed into a deterministic context pack, and that pack is what would be sent to a provider. The pack should be inspectable on disk so that context assembly can be debugged and iterated without relying on model behavior.

## Input, processing, output

Input is a bundle rather than a string. It includes the current working directory, inferred workspace roots, the selected mode, the selected provider and model, and the user message.

Processing is an in-process UI plus an engine subprocess. The cockpit is responsible for interaction and display. The engine subprocess is responsible for context assembly and provider request construction. In v2, the default engine implementation assembles a mode-specific `system` prompt from bundled Atlas templates and does not call provider APIs.

Output is mode dependent, but always split into two destinations. Chat output is the immediate conversational surface. File output is durable memory for inspection and re-entry. In v2 the durable output is an assembled-context log file written on each submit.

## Modes

Interpret mode is the bridge from messy operator input to a structured artifact. The current mental model is marco-to-polo and the output contract should be oriented around producing a spec-shaped artifact or an intent check.

Plan mode is the bridge from polo to scoped execution. In v2 it exists primarily to shape projections and UI semantics. The protocol and projection are stubs whose output expectation is phased planning plus explicit OPEN items.

Execute mode is the bridge from spec to repo diffs plus verification. In v2 it exists to shape projections and to establish where automatic file mutation and verification will later occur.

## TUI surface

The first pass cockpit is intentionally minimal but complete: chat transcript and composer, a mode selector, a provider/model selector, a repo tree and basic repo health, and a project/inspection panel. Submitting a message triggers context assembly via the engine subprocess and writes an assembled-context log for inspection.

## Workspace discovery

Workspace discovery is robust enough that the app can be launched from anywhere inside a devOS repo. If an Atlas project wrapper exists (the directory containing `now.md`, `specs/`, `logs/`, `.atlas/version`, and `repo/`), it becomes the authoritative root and logs are written to the wrapper logs area. Otherwise, the nearest `.git` root is treated as the managed repo root and logs are written to a local `.atlas-tui/` folder.
